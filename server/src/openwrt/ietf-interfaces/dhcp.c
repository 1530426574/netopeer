/**
 * \file dhcp.c
 * \brief Implementation of dhcp client/server configuration
 * \author Peter Nagy <xnagyp01@stud.fit.vutbr.cz>
 * \date 2016
 *
 * Copyright (C) 2016 CESNET
 *
 * LICENSE TERMS
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of the Company nor the names of its contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * ALTERNATIVELY, provided that this notice is retained in full, this
 * product may be distributed under the terms of the GNU General Public
 * License (GPL) version 2 or later, in which case the provisions
 * of the GPL apply INSTEAD OF those given above.
 *
 * This software is provided ``as is'', and any express or implied
 * warranties, including, but not limited to, the implied warranties of
 * merchantability and fitness for a particular purpose are disclaimed.
 * In no event shall the company or contributors be liable for any
 * direct, indirect, incidental, special, exemplary, or consequential
 * damages (including, but not limited to, procurement of substitute
 * goods or services; loss of use, data, or profits; or business
 * interruption) however caused and on any theory of liability, whether
 * in contract, strict liability, or tort (including negligence or
 * otherwise) arising in any way out of the use of this software, even
 * if advised of the possibility of such damage.
 *
 */

#define _GNU_SOURCE
#define _XOPEN_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "dhcp.h"
#include "ietf-interfaces.h"
#include "../config-parser/parse.h"

static int if_sec_id = 0;

int iface_ipv4_origin(const char* if_name, unsigned char origin, XMLDIFF_OP op, char** msg)
{
	char* cmd;
	FILE* output;
	struct interface_section if_section;

	char *path = NULL;
	char** section = NULL;
	unsigned int section_count;
	unsigned int i;

	/* remove first dhcp interface section */
	if ((op & XMLDIFF_MOD) || (op & XMLDIFF_REM)) {
		if ((section = get_interface_section(if_name, &section_count)) != NULL) {
			for (i = 0; i < section_count; ++i) {
				free(path);
				asprintf(&path, "network.%s.proto", section[i]);
				if (strcmp(get_option_config(path), "dhcp") == 0) {
					rm_config_section(path);
					break;
				}
				free(section[i]);
			}
			free(path);
		}
		free(section);
	}

	/* dhcp - client */
	if (origin) {
		/* start a new dhcp client */
		asprintf(&cmd, "udhcpc -p /var/run/udhcpc-%s.pid -t 0 -i %s -C", if_name, if_name);
		output = popen(cmd, "r");
		free(cmd);

		if (output == NULL) {
			asprintf(msg, "%s: failed to execute a command.", __func__);
			return EXIT_FAILURE;
		}
		pclose(output);

		/* pernament */
		if_sec_id++;
		asprintf(&(if_section.section), "%s%d", if_name, if_sec_id);
		if_section.ifname = strdup(if_name);
		if_section.ipv4_addr = NULL;
		if_section.ipv4_netmask = NULL;
		if_section.ipv6_addr = NULL;
		if_section.proto = 1;

		if (add_interface_section(&if_section) != EXIT_SUCCESS) {
			asprintf(msg, "%s: Configuring interface %s failed.", __func__, if_name);
			free(if_section.section);
			free(if_section.ifname);
			return EXIT_FAILURE;
		}
		free(if_section.section);
		free(if_section.ifname);
	} else {
		/* kill dhcp client if any */
		char* line;
		FILE* fileptr;
		size_t len = 0;
		char* dhcp_pid_path;
		asprintf(&dhcp_pid_path, "/var/run/udhcpc-%s.pid", if_name);
		if ((fileptr = fopen(dhcp_pid_path, "r")) == NULL) {
			/* dhcp not running on current interface - do noting */
			return EXIT_SUCCESS;
		}

		if (getline(&line, &len, fileptr) != -1) {
			asprintf(&cmd, "kill %s", line);
			output = popen(cmd, "r");
			free(cmd);

			if (output == NULL) {
				asprintf(msg, "%s: failed to execute a command.", __func__);
				return EXIT_FAILURE;
			}
			pclose(output);
		}
		free(line);
	}

	/* do noting if manual */
	return EXIT_SUCCESS;
}

int dhcp_ipv4_server(const char* if_name, char* start, char* stop, char* leasetime, char* default_gateway, XMLDIFF_OP op, char** msg)
{
	FILE *dhcp_config;

	if (op & XMLDIFF_ADD) {

		if ((dhcp_config = fopen("/etc/dnsmasq.conf", "a")) == NULL) {
			asprintf(msg, "%s: failed to open /etc/dnsmasq.conf.", __func__);
			return EXIT_FAILURE;
		}

		fprintf(dhcp_config, "\n# Auto-generated by netopeer-server");
		fprintf(dhcp_config, "dhcp-range=%s,%s,%s,%s", if_name, start, stop, leasetime);
		fprintf(dhcp_config, "dhcp-option=%s,3,%s", if_name, default_gateway);

		fclose(dhcp_config);

	} else if (op & XMLDIFF_REM) {
		FILE *dhcp_config_tmp;
		char* dhcp_range, *dhcp_option;
		char *line = NULL;
		size_t len = 0;
		ssize_t read;

		if ((dhcp_config = fopen("/etc/dnsmasq.conf", "r")) == NULL) {
			asprintf(msg, "%s: failed to open /etc/dnsmasq.conf.", __func__);
			return EXIT_FAILURE;
		}
		if ((dhcp_config_tmp = fopen("/tmp/dnsmasq.tmp", "w")) == NULL) {
			asprintf(msg, "%s: failed to open /tmp/dnsmasq.tmp.", __func__);
			return EXIT_FAILURE;
		}

		asprintf(&dhcp_range, "dhcp-range=%s,%s,%s,%s", if_name, start, stop, leasetime);
		asprintf(&dhcp_option, "dhcp-option=%s,3,%s", if_name, default_gateway);

		while ((read = getline(&line, &len, dhcp_config)) != -1) {
			if ((strcmp(line, dhcp_range) != 0) && (strcmp(line, dhcp_option) != 0) && (strcmp(line, "# Auto-generated by netopeer-server") != 0)) {
				fprintf(dhcp_config_tmp, "%s", line);
			}
		}

		free(line);
		free(dhcp_range);
		free(dhcp_option);
		fclose(dhcp_config);
		fclose(dhcp_config_tmp);
		if (rename("/tmp/dnsmasq.tmp", "/etc/dnsmasq.conf") == -1) {
			asprintf(msg, "%s: failed to replace /etc/dnsmasq.conf.", __func__);
			return EXIT_FAILURE;
		}
	}
	
	return EXIT_SUCCESS;
}

static char *convert_ip_reverse_little_endian(char *input_gateway)
{
	char* gateway_copy = input_gateway;
	char octet[2];
	long int first_octet, second_octet, third_octet, fourth_octet;
	char* gateway = NULL;
	char* ptr = NULL;

	if (strlen(input_gateway) != 8) {
		return NULL;
	}

	strncpy(octet, gateway_copy, 2);
	fourth_octet = strtol(octet, &ptr, 16);
	gateway_copy += 2;
	strncpy(octet, gateway_copy, 2);
	third_octet = strtol(octet, &ptr, 16);
	gateway_copy += 2;
	strncpy(octet, gateway_copy, 2);
	second_octet = strtol(octet, &ptr, 16);
	gateway_copy += 2;
	strncpy(octet, gateway_copy, 2);
	first_octet = strtol(octet, &ptr, 16);

	asprintf(&gateway, "%ld.%ld.%ld.%ld", first_octet, second_octet, third_octet, fourth_octet);
	return gateway;
}

char* dhcp_get_ipv4_default_gateway(const char* if_name, char** msg)
{
	char* gateway = NULL;
	char *line = NULL;
	FILE *f;
	char *interface, *dest, *gate;
	size_t len;

	if ((f = fopen("/proc/net/route" , "r")) == NULL) {
		asprintf(msg, "%s: unable to open \"/proc/net/route\"", __func__);
		return NULL;
	}

	while(getline(&line, &len, f) != -1) {
		interface = strtok(line , " \t");
		dest = strtok(NULL, " \t");
		gate = strtok(NULL, " \t");

		if(dest!=NULL && gate!=NULL && (strcmp(interface, if_name) == 0)) {
			if(strcmp(dest , "00000000") == 0) {

				/* convert gateway */
				if ((gateway = convert_ip_reverse_little_endian(gate)) == NULL) {
					asprintf(msg, "%s: unable to convert gateway address", __func__);
					return NULL;
				}
				break;
			}
		}
	}
	fclose(f);
	free(line);
	return gateway;
}

char* dhcp_get_ipv6_default_gateway(const char* if_name, char** msg)
{
	char* gateway = NULL;
	char *line = NULL;
	FILE *f;
	char *interface = NULL, *dest = NULL, *gate = NULL, *token = NULL;
	size_t len;
	int i;

	if ((f = fopen("/proc/net/ipv6_route" , "r")) == NULL) {
		asprintf(msg, "%s: unable to open \"/proc/net/ipv6_route\"", __func__);
		return NULL;
	}

	while(getline(&line, &len, f) != -1) {
		/* destination defined in column 5 */
		dest = strtok(line , " \t");
		if (strcmp(dest, "00000000000000000000000000000000") != 0) {
			continue;
		}

		i = 1;
		while((token != NULL) || i < 10) {
			/* gateway defined in column 5 */
			if (i == 5) {
				gate = token;
			}
			/* interface defined in column 10 */
			if (i == 10) {
				interface = token;
				interface[strlen(interface)-1] = '\0';
			}

			i++;
			token = strtok(NULL, " \t");
		}

		if(dest != NULL && gate != NULL && (strcmp(interface, if_name) == 0)) {

			/* format gateway */
			if ((gateway = calloc(40, sizeof(char))) == NULL) {
				asprintf(msg, "%s: memory allocation problem - cannot format ip address", __func__);
				return NULL;
			}

			for (i = 0; i < 8; i++) {
				gateway = strncat(gateway, gate, 4);
				if (i < 7) {
					gateway = strcat(gateway, ".");
				}
				gate += 4;
			}
			break;
		}
	}
	fclose(f);
	free(line);
	return gateway;
}

char** dhcp_get_dns_server(char** msg)
{
	char* path;
	char** nameservers;

	/* get path to dns resolv.conf file */
	if ((path = get_option_config("dhcp.dnsmasq.resolvfile")) == NULL) {
		asprintf(msg, "%s: unable to get path to resolv file", __func__);
		return NULL;
	}

	if ((nameservers = dns_get_nameserver(path)) == NULL) {
		asprintf(msg, "%s: unable to get nameservers", __func__);
		free(path);
		return NULL;
	}
	free(path);
	return nameservers;
}

char** dhcp_get_dns_search(char** msg)
{
	char* path;
	char** search;

	/* get path to dns resolv.conf file */
	if ((path = get_option_config("dhcp.dnsmasq.resolvfile")) == NULL) {
		asprintf(msg, "%s: unable to get path to resolv file", __func__);
		return NULL;
	}

	if ((search = dns_get_search_domain(path)) == NULL) {
		asprintf(msg, "%s: unable to get search domain", __func__);
		free(path);
		return NULL;
	}
	free(path);
	return search;
}

xmlNodePtr dhcpv4_getconfig(xmlNsPtr ns, const char* if_name, char** msg)
{
	FILE *dhcp_config;
	char* dhcp_range, *dhcp_option;
	xmlNodePtr dhcp_node;
	char *line = NULL;
	size_t len = 0;
	ssize_t read;
	char* token = NULL;
	int i = 0;

	/* dhcp-server */
	dhcp_node = xmlNewNode(ns, BAD_CAST "dhcp-server");

	if ((dhcp_config = fopen("/etc/dnsmasq.conf", "r")) == NULL) {
		asprintf(msg, "%s: failed to open /etc/dnsmasq.conf.", __func__);
	}

	asprintf(&dhcp_range, "dhcp-range=%s", if_name);
	asprintf(&dhcp_option, "dhcp-option=%s,3", if_name);

	while ((read = getline(&line, &len, dhcp_config)) != -1) {
		if (strncmp(dhcp_range, line, strlen(dhcp_range)) == 0) {

			/* Parse dhcp-server configuration */
			token = strtok (line ,",");
			i = 0;
			while (token != NULL){

				if (i == 1) {
					xmlNewChild(dhcp_node, dhcp_node->ns, BAD_CAST "start", BAD_CAST token);
				}
				if (i == 2) {
					xmlNewChild(dhcp_node, dhcp_node->ns, BAD_CAST "stop", BAD_CAST token);
				}
				if (i == 3) {
					xmlNewChild(dhcp_node, dhcp_node->ns, BAD_CAST "leasetime", BAD_CAST token);
				}

				i++;
				token = strtok (NULL, ",");
			}
		}

		if (strncmp(dhcp_option, line, strlen(dhcp_option)) == 0) {
			
			/* Parse default-gateway configuration */
			token = strtok (line ,",");
			i = 0;
			while (token != NULL){

				if (i == 2) {
					xmlNewChild(dhcp_node, dhcp_node->ns, BAD_CAST "default-gateway", BAD_CAST token);
				}

				i++;
				token = strtok (NULL, ",");
			}
		}
	}

	return dhcp_node;
}
